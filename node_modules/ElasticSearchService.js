// noinspection JSUnresolvedFunction
let path = require('path');


exports.ElasticSearchService = class ElasticSearchService {

    /**
     * Executes a signed action (method + body) against the elastic search domain + path
     * @param method
     * @param path
     * @param bodyObj
     * @param callback
     */
    execute(method='POST', path, bodyObj, callback) {

        // noinspection JSUnresolvedFunction
        let req = new this.aws.HttpRequest(this.elasticSearchEndPoint);
        req.method = method;
        req.path = path;
        req.region = this.region;
        // noinspection JSValidateTypes
        req.headers['presigned-expires'] = false;
        req.headers['Host'] = this.elasticSearchEndPoint.host;
        req.headers['Content-Type'] = "application/json";
        if (bodyObj !== null) {
            req.body = JSON.stringify(bodyObj);
        }

        if (bodyObj === null || (bodyObj !== null && req.body !== false) ) {

            //noinspection JSUnresolvedVariable,JSUnresolvedFunction
            let signer = new this.aws.Signers.V4(req, 'es');  // es: service code
            //noinspection JSUnresolvedFunction
            signer.addAuthorization(this.awsCredentials, new Date());

            //noinspection JSUnresolvedFunction
            let send = new this.aws.NodeHttpClient();
            //noinspection JSUnresolvedFunction
            send.handleRequest(req, null, function (httpResp) {

                let respBody = '';

                // noinspection JSUnresolvedFunction
                httpResp.on('data', function (chunk) {
                    respBody += chunk;
                });
                // noinspection JSUnresolvedFunction
                httpResp.on('end', function () {
                    if (typeof callback === 'function') callback(null, respBody);
                });

            }, function (err) {
                if (typeof callback === 'function') callback(err, null);
            });

        } else {
            if (typeof callback === 'function') callback({"message":"ElasticSearch.query error: invalid json provided"}, null);
        }

    }

    //Private
    _generateMappingForStructure(structure) {

        let mapping = {
            _source: {
                enabled: true,
                includes: []
            },
            dynamic: "false",
            properties: {}
        };

        Object.keys(structure).forEach(function(field){

            let type = structure[field];
            mapping._source.includes.push(field);
            mapping.properties[field] = { type : type };

            //String and its enhanced variants
            if (['string','autocomplete','cvs','phone'].indexOf(type) !== -1 ) {
                mapping.properties[field]['fields'] = {
                    raw : {
                        type : 'string',
                        index : 'not_analyzed',
                        ignore_above : 10922
                    },
                    row_lower : {
                        type : 'string',
                        analyzer : 'keyword_lower',
                        ignore_above : 10922
                    }
                };
            }

            if (type === 'boolean') {
                mapping.properties[field]['null_value'] = false;
            }

            if (type === 'geo_point') {
                mapping.properties[field]['geohash'] = true;
                mapping.properties[field]['geohash_precision'] = 10;
            }

            if (type === 'date') {
                mapping.properties[field]['format'] = "YYYY-MM-dd HH:mm:ss.SSSSSS||YYYY-MM-dd||YYYY/MM/dd";
                mapping.properties[field]['fields'] = {
                    to_string: {
                        'type': 'string',
                        'index': 'not_analyzed'
                    }
                };
            }

            if (type === 'phone') {
                mapping.properties[field]['type'] = 'string';
            }


            if (type === 'autocomplete') {
                mapping.properties[field]['type'] = 'string';
                mapping.properties[field]['index_analyzer'] = 'autocomplete';
                mapping.properties[field]['search_analyzer'] = 'standard';
            }

            if (type === 'cvs') {
                mapping.properties[field]['type'] = 'string';
                mapping.properties[field]['index_analyzer'] = 'cvs';
                mapping.properties[field]['search_analyzer'] = 'standard';
            }


        });

        return mapping;
    }

    //private
    _generateIndexDefinition(docType, structure) {

        let indexDef = {
            settings : {
                analysis : {
                    filter : {
                        shingle : {
                            type : "shingle"
                        }
                    },
                    analyzer : {
                        keyword_lower : {
                            type : "custom",
                            tokenizer : "keyword",
                            filter : ['lowercase']
                        }
                    }
                }
            },
            mappings : {}
        };


        let mapName = String(docType).toLowerCase() + '_map_type';
        indexDef.mappings[mapName] = this._generateMappingForStructure(structure);

        let hasAutocomplete = false;
        let hasCsv = false;
        Object.keys(structure).forEach(function(key) {
            if (structure[key] === 'autocomplete') {
                hasAutocomplete = true;
            }
            if (structure[key] === 'cvs') {
                hasCsv = true;
            }
        });

        if (hasAutocomplete) {

            indexDef.settings['number_of_shards'] = 1;
            indexDef.settings['analysis']['filter']['autocomplete_filter'] = {
                type : 'edge_ngram',
                min_gram : 1,
                max_gram : 20
            };

            indexDef.settings['analysis']['analyzer']['autocomplete'] = {
                type : 'custom',
                tokenizer : 'standard',
                filter : [ 'lowercase', 'autocomplete_filter']
            };

        }

        if (hasCsv) {

            //reference http://stackoverflow.com/questions/29260967/elastic-search-any-way-to-make-space-separated-words-in-a-comma-separated-list
            indexDef.settings['number_of_shards'] = 1;
            indexDef.settings['analysis']['analyzer']['cvs'] = {
                type : 'pattern',
                pattern : ', ',
                lowercase : true
            };

        }

        return indexDef;


    }


    createIndex(indexName, docType, structure, callback) {
        try {
            let newStructure = JSON.parse(structure);
            let docTypeLower = String(docType).toLowerCase();
            let definition = this._generateIndexDefinition(docTypeLower, newStructure);
            let url = path.join('/', indexName, docTypeLower);
            console.log('Creating ES Index ' + url, JSON.stringify(definition), "Structure", structure);
            this.execute("POST", url, definition, callback);
        } catch (ex) {
            if (typeof callback === 'function') callback({'message':'Invalid structure json'},null);
        }
    };


    deleteIndex(indexName, callback) {
        let url = path.join('/', indexName);
        console.log('Deleting ES Index ' + url);
        this.execute("DELETE", url, null, callback);
    }

    deleteAlias(aliasName, indexName, callback) {
        let actions = {
            actions: [{
                remove : {
                    index: indexName,
                    alias: aliasName
                }
            }]
        };
        this.execute("POST","/_aliases", actions, callback);
    }


    putAlias(aliasName, oldIndex, newIndex, callback) {

        let actions = {
            actions: []
        };

        if (oldIndex !== '') {
            actions.actions.push({
                remove : {
                    index : oldIndex,
                    alias : aliasName
                }
            });
        }

        actions.actions.push({
            add : {
                index : newIndex,
                alias : aliasName
            }
        });

        this.execute("POST","/_aliases", actions, callback);

    }


    constructor(awsApiInstance, region, elasticSearchEndPoint) {
        this.aws = awsApiInstance;
        // noinspection JSUnresolvedFunction
        this.awsCredentials = new this.aws.EnvironmentCredentials('AWS');
        this.region = region;
        // noinspection JSUnresolvedFunction
        this.elasticSearchEndPoint = new this.aws.Endpoint(elasticSearchEndPoint);
    }
};